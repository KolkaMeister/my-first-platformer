# Мой первый платформер

## Это мой первый платформер который я сделал в ходе курса от XYZSchool

[Ссылка на курс](https://www.school-xyz.com/unity)

### Реализация эффектов окружения и анимаций

Для обеспечения в игре не статичной картинки, придания живости, по курсу были предложены: аниматор, партиклы (сплеши от атак, пыль от перемещения, эффект ветра, телепорта и тд.) и самописный скрипт для спрайт анимации. Я придумал и свои скрипты, такие как колебания объектов и периодическое свечение (изменение интенсивности).

Самописные скрипты были нужны для улучшения производительности, оптимизации проекта и для небольшой рандомизации происходящего.

### Инвентарь, сессия, модели данных, чекпоинты, definitions

- В проекте есть класс `GameSession`, в каждой сцене он может быть только один. Это большое хранилище информации о сессии: чекпоинты, инвентарь, перки, характеристики, ивенты. У большинства из этих данных есть свои модели, которые инициализируются в методе Awake. Модели имеют ивенты для отслеживания изменений в данных сессии и методы для изменения этих данных.

- Definitions - это группа классов наследуемых от `ScriptableObject`, которые предназначены для получения из них информации о характеристике персонажа на разных уровнях прокачки, предметах, перках. У объектов задекларированных в definitions главным параметром для поиска является идентификатор (string и enum), по которому можно найти нужный предмет/перк/характеристику и забрать нужную информацию.

- Чекпоинты - это объект при достижении которого его ID записывается в `GameSession` в переменную `checkPointId`. При смерти персонажа уровень перезапускается, вызывается метод спавна героя, который ищет по всему уровню чекпоинты с `Id` равным `checkPointId`, если такого чекпоинта нету, начинается поиск чекпоинта с `Id` равным `default` (такие есть на каждом уровне) и спавнит на месте дефолтного чекпоинта персонажа.

- Инвентарь представляет собой экземпляр класса `Inventory Data` который хранит в себе все предметы полученные игроком. Чтобы добавить предмет в инвентарь вызывается метод `Add` принимающий в качестве аргументов `id` и количество`count`, в котором проверяется по `Id` есть ли этот предмет в definitions `InventoryItemsDefs` если таковой имеется, то происходит проверка на присутствие этого предмета в инвентаре, добавление к уже присутствующему прдемету количества, которое передано в метод, или, если такого предмета нету, создается новый с переданным количеством. В случае не нахождения этого предмета в definitions метод прерывается. Также инвентарь имеет метод `GetItems` получения всех предметов которые имеют теги, переданные в качестве аргумента. `Remove`- удаления предмета, `Count` - подсчет количества предметов, `IsEnought`- проверка на имение всех нужных предметов в нужном количестве.

#### Примеры

- Модель быстрого инвентаря

    При создании экземпляра класса в конструктор передается `PlayerData` (класс, хранящий информацию о предметах в инвентаре), экземпляр класса подписывается на изменения его инвентаря и заполняет массив предметами, которые имеют тег Usable.
    Предметы представляют собой экземпляры `InventoryItemData` (класс, имеющий идентификатор, максимально допустимое количество в стаке и текущее количество). В случае добавления или удаления предмета с тегом Usable, модель заново запросит все предметы с этим тегом и присвоит в массив. В модели есть event который вызывается при ребилде быстрого инвентаря, на который могут подписаться интересанты.

### Мобы, герой, взаимодействие с игровыми объектами

#### Важные скрипты для реализаций основных механик

- `CheckCircleOverlap` - проверяет `GameObject` по `layer` и `tag`, если все подходит то срабатывает UnityEvent и передает этот `GameObject` в качестве аргумента. Этим компонентом реализована melee атака персонажей и взаимодействие с объектами со слоем `Interactable`.

- `ColliderCheck` - проверяет коллайдер на наличие соприкосновения с `GameObject`, имеющими нужный `layer` и записывает результат в переменную `IsTouchingLayer`

- `Patrol` - абстрактный класс имеющий двух наследников, которые реализуют патрулирование: по точкам, размещенным по сцене, либо по платформе

- `Enter trigger` и `Enter collision` - при соприкосновении с `GameObject` проверяет по `layer` и `tag`, если все подходит то срабатывает UnityEvent и передает этот `GameObject` в качестве аргумента

- `HealthComponent` - компонент для расчета здоровья `GameObject`, имеющий методы для восстановления, уменьшения здоровья, блокировки нанесения урона и ивенты для отслеживания изменения здоровья, смерти

- `ModifyHealthComponent` - компонент служащий для изменения здоровья `GameObject` с  компонентом `HealthComponent`, имеет функции для нанесения урона и восстановления здоровья

- `GamePerson` - класс, имеющий базовую реализацию персонажей (атака, ходьба)

- `HeroInputReader` - класс для считывания нажатия клавиш через новую `InputSystem` и воздействия на персонажа класса `Hero`.

- `MobAI` - скрипты этой категории определяют поведение противников, их действия в бою и вне его.

#### Примеры

- Пример с героем. `HeroInputReader` передает `Vector2` значение считанного с контроллеров (клавиатура, стик), записывает его в переменную direction у нашего персонажа и в методе `FixedUpdate` рассчитывается ускорение объекта, поворот, анимации. Персонаж начинает двигаться, соприкасается с монеткой, у нее срабатывает метод `OnTriggerEnter2D`, в котором проверяется `layer` и `tag`, срабатывает `UnityEvent` подписчиком которого является метод `AddToInventory` из класса `InventoryAddComponent`. Это метод проверяет, имеет ли наш герой реализацию интерфейса `ICanAddToInventory` и вызывает метод интерфейса `AddToInventory`. В этом методе вызывается метод `Add` у инвентаря сессии, которую мы нашли в сцене на старте `Start`.

- Пример с противником-пиратом. Наш герой соприкасается с коллайдером объекта `Vision` который находится на пирате. `EnterTriggerComponent` вызывает метод `OnHeroVision` у `MobAI`. Запускается курутина `Agro`, для маленькой задержки перед преследованием, затем `GoToTarget`, где в цикле `While` до тех пор пока герой находится в коллайдере объекта `Vision` проверяется, касание коллайдера `AttackRange` с героем, если касается, то запускается курутина `Attack` (в ней происходит вызов атаки у компонента `GamePerson`, который также прокинут на пирата), которая заново вызывает курутину `GoToTarget` (все курутины запускаются через метод `StartState` чтобы нельзя было использовать несколько курутин одновременно). Если персонаж потерян из виду, то преследование заканчивается.

### Настройки, локализация, синглтоны

- Для настроек звука и языка в игре используются наследники абстрактного класса `PrefsPersistantPropery`. Данный класс позволяет сохранять данные в памяти через свойство `Value`. При присваивании значения в свойство проверяется не равно ли текущее значение переменной `stored` (значение которое записано в памяти), если не равно, то происходит запись в память нового значения через класс `PlayerPrefs` и в переменную `stored` нового значения, если же значения равны, тогда запись нового значения прерывается (это микро оптимизация нужна чтобы не использовать лишний раз вызов ивента и записи через `PlayerPrefs`).

#### Звук

- `GameSettings` - синглтон, наследник `ScriptableObject`, который хранит в себе две `FloatPersistantProperty`, это настройки звука музыки и эффектов. Этот синглтон работает на ресурсах. При  вызове статического конструктора, мы в ресурсах ищем экземпляр класса `GameSettings` и присваиваем в статическую переменную.

#### Локализация

- `LocaleDef`- наследник `ScriptableObject`, имеет ссылку на гугл таблицу, из которой методом `UnityWebRequest.Get` получает данные о таблице и парсит их в лист с `LocaleItem` (экземпляр класса хранит в себе ключ и значение к нему). Метод `GetData` возвращает словарь со всеми ключами и значениями.

- `LocalizationManager`- синглтон имеющий ивент для отслеживания смены языка, методы для получения значения по ключу `GetByKey` и загрузки нужной локализации `LoadLocale`.

- `Localize`- компонент имеющий ключ по которому будет искаться нужное значение через `LocalizationManager`.

- `LocaleItemWidget`- компонент который вещается на кнопку для смены локализации.

#### Примеры

- Компонент `SoundSetController` на методе `Start` в зависимости от выбранного в инспекторе Enuma берет значение громкости звука из `GameSettings`, подписывается на его изменение и присваивает нужному `AudioSource` в переменную `volume`. В случае смены громкости в `volume` запишется новое значение.

- Компонент `Localize` на методе `Start` делает обращается к статической переменной класса `LocalizationManager` под названием `I`. Если обращение к классу было первым за время работы программы, то вызывается статический конструктор который создает и присваивает в переменную `I` экземпляр класса `LocalizationManager`. Созданный экземпляр класса в обычном конструкторе ищет по значению `LocaleKey` нужный `LocaleDef` в ресурсах, присваивает в переменную `localeDef` и забирает оттуда словарь с ключами и их переводами. Затем компонент ищет нужное ей значение через `LocalizationManager.I.GetByKey`, если находит, то метод возвращет его компоненту, иначе возвращается ключ в таком формате: `%%%{ключ}%%%`

- `LocaleItemWinget` на кнопке при нажатии вызывает у `LocalizationManager` метод `LoadLocale` с аргументом `key` в котором сначала проверяется, есть ли `LocaleDef` с таким названием (проверяется лист `LocaleNames` на наличие переданного ключа), если есть, то достается нужный `LocaleDef` из ресурсов, присваивается в переменную, обновляется словарь (вызывается метод `GetData` у текущего `LocaleDef`) и срабатывает ивент `OnLocaleLoaded`.

### UI, LevelLoader , AnimatedWindow, GeneralUIController, DataGroup

#### Кнопки

Для кастомного анимирования кнопок и добавления звука были написаны скрипты `CustomButton` и `ButtonSound`.

- `ButtonSound` - реализует интерфейс `IPointerClickHandler`. При нажатии на кнопку ищет в сцене `AudioSource` с тегом `SFX` и воспроизводит на нем `AudioClip` прокинутый в инспекторе.

- `CustomButton`- наследник класса `Button`, переопределяет метод `DoStateTransition` чтобы добавить эффект перемещения текста на кнопке вместе с анимацией кнопки.

#### DataGroup

Этот класс нужен для создания однотипных объектов с разными параметрами. В классе в котором вы хотим его использовать, в инспекторе прокидываем контейнер, в котором будут храниться эти объекты и класс имеющий реализацию интерфейса `IItemRenderer` (те объекты которые мы будем плодить) и на методе старт инициализируем в переменную класса `DataGroup` указывая контейнер и объект который нужно создавать и передавать туда параметры. `PredefinedDataGroup` - его наследник который работает по похожему принципу, только вместо создания новых, он берет уже созданное количество и отключает лишние и больше не создает новые.

Можно разобрать на примере инвентаря.

- `QuickInventoryHud` на старте подписывается на `QuickInventoryModel`, хранящуюся в `GameSession` и забирает из нее данные о предметах которые там находятся, инициализирует `DataGroup` контейнер и `InventoryItemWidget`, который он будет размножать. Затем вызывается метод `SetData` у `DataGroup` в него передается массив с теми данными для `InventoryItemWidget`. Eсли количество переданных данных (элементов массива) меньше, чем уже созданных `InventoryItemWidget`, то у виджетов вызывается метод `SetActive` с аргументом `false` и наоборот.

#### LevelLoader

`LevelLoader`- класс для реализации красивых переходов между уровнями. Имеет статический метод с атрибутом `[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]` (вызывается после загрузки первой же сцены в игре) для загрузки сцены с `GameObject` имеющим на нем `LevelLoader`. На старте вызывается метод `DontDestroyOnLoad`, поэтому не нужно постоянно подгружать сцену с `LevelLoader`, хватает одного раза. Переход осуществляется нахождением этого объекта в сессии, вызова метода `LoadScene` с передачей в метод названия нужной сцены. В этом методе вызывается курутина которая показывает экран перехода и запускает асинхронную загрузку нужной сцены, когда сцена загрузилась выключает показ экрана.

#### Окна

- `AnimatedWindow`- базовый класс для окон, с реализации анимации для закрытия и открытия с анимационным ивентом в конце закрытия.

- `GeneralUIController`- контроллер подгружающийся из ресурсов на старте сессии, с различными окнами(диалоговые, перки, характеристики и тп). С помощью его осуществляется открытие окон, привязанных к персонажу, управление курсором, отключение компонента `PlayerInput` на герое и интерфейса (инвентарь, шкала здоровья).

- Локеры - группа этих классов работает по такому принципу: у локеров есть методы `Retain` и `Dispose` и лист с теми объектами, которые залочили его `lockers`. Если лист имеет хотя бы рдин объект, то он залочен.

#### Примеры

- Игрок нажимает кнопку `I`, `HeroInputReader` ищет в сцене `GeneralUIController` и вызывает метод `OpenStatsWindow` в котором закрывается текущее окно связанное с героем если оно открыто, и вызывается метод `Open` у окна `StatsWindow` для его открытия и добавления себя же в локер который отвечает за курсор, чтобы включить курсор, при нажатии на крестик окно закроется и в конце уберет себя из локера, что выключит курсор.Если мы нажмем вместо крестика на `P`, то вызовется метод `OpenPerksWindow` у `GeneralUIController`, закроется `StatsWindow` и откроется `PerksWindow`.

- Игрок подходит к объекту с слоем `Interactable` и нажимает `E` происходит интеракция. Компонент `StartDialogComponent` на объекте находит `GeneralUIController` и вызывает метод `StartDialog` который закрывает окна связанные с героем (перки, инвентарь) и начинает диалог, в начале диалога выключается `PlayerInput` у `Hero` и с помощъю локеров выключается интерфейс и включается курсор, в конце диалога локеры и `Player Input` заново включаются и срабатывает ивент `OnEndDialog`.

- При нажатии на `Esc` вызывается метод `OpenInGameMenuWindow` у `GeneralUIController`, в котором открывается `InGameMenu`, включается блокер и останавливается время. При закрытии меню в анимационный ивент `OnClose` записывается анонимный метод, в котором у `GeneralUIController` вызывается метод `Resume`, который выключает блокер и восстанавливает время.
